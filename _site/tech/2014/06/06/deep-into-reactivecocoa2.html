<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>YangShanghai's HQ</title>
	<link rel="shortcut icon" href="/image/logo.png">
	<link rel="stylesheet" type="text/css" href="/css/style.css" />
	<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/lzyy">
</head>

	<body>
		<div id="nav">
	<div class="wrapper">
		<div id="logo"><a href="/"><img src="/image/logo.png" /></a></h1></div>
		<ul>
			<li id="category-iOS"><a href="/category/iOS.html">iOS</a></li>
			<li id="category-tech"><a href="/category/tech.html">技术</a></li>
			<li id="category-essay"><a href="/category/essay.html">随笔</a></li>
			<li id="category-reading"><a href="/category/reading.html">阅读</a></li>
			<li id="category-design"><a href="/category/design.html">设计</a></li>
			<li id="category-quotes"><a href="/quotes.html">引言</a></li>
		</ul>
	</div>
</div>

<script>
var category = location.pathname;
if (category == '/') {
	document.getElementById('category-all').style.textDecoration = "underline";
} else if (category == '/category/iOS.html') {
	document.getElementById('category-iOS').style.textDecoration = "underline";
} else if (category == '/category/tech.html') {
	document.getElementById('category-tech').style.textDecoration = "underline";
} else if (category == '/category/design.html') {
	document.getElementById('category-design').style.textDecoration = "underline";
} else if (category == '/category/essay.html') {
	document.getElementById('category-essay').style.textDecoration = "underline";
} else if (category == '/category/reading.html') {
	document.getElementById('category-reading').style.textDecoration = "underline";
} else if (category == '/quotes.html') {
	document.getElementById('category-quotes').style.textDecoration = "underline";
} else if (category == '/category/weekly-recommendation.html') {
	document.getElementById('weekly-recommendation').style.textDecoration = "underline";
}

</script>

		<div class="wrapper main">
			<div id="content">
				<h2>ReactiveCocoa2实战</h2>
				<div class="cnt">
					<p>之前已经写过两篇关于ReactiveCocoa(以下简称RAC)的文章了，但主要也是在阐述基本的概念和使用，这篇文章将会从实战的角度来看看RAC到底解决了哪些问题，带来了哪些方便，以及遇到的一些坑。</p>

<h3 id="概述">概述</h3>

<h4 id="为什么要使用rac">为什么要使用RAC？</h4>

<p>一个怪怪的东西，从Demo看也没有让代码变得更好、更短，相反还造成理解上的困难，真的有必要去学它么？相信这是大多数人在接触RAC时的想法。RAC不是单一功能的模块，它是一个Framework，提供了一整套解决方案。其核心思想是「响应数据的变化」，在这个基础上有了Signal的概念，进而可以帮助减少状态变量(可以参考jspahrsummers的<a href="https://github.com/jspahrsummers/enemy-of-the-state">PPT</a>)，使用MVVM架构，统一的异步编程模型等等。</p>

<p>为什么RAC更加适合编写Cocoa App？说这个之前，我们先来看下Web前端编程，因为有些相似之处。目前很火的AngularJS有一个很重要的特性：数据与视图绑定。就是当数据变化时，视图不需要额外的处理，便可正确地呈现最新的数据。而这也是RAC的亮点之一。RAC与Cocoa的编程模式，有点像AngularJS和jQuery。所以要了解RAC，需要先在观念上做调整。</p>

<p>以下面这个Cell为例</p>

<p><img src="/image/rac-demo.png" alt="" /></p>

<p>正常的写法可能是这样，很直观。</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">configureWithItem</span><span class="p">:(</span><span class="n">HBItem</span> <span class="o">*</span><span class="p">)</span><span class="nv">item</span>
<span class="p">{</span>
	<span class="n">self</span><span class="p">.</span><span class="n">username</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">text</span><span class="p">;</span>
	<span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">avatarImageView</span> <span class="nf">setImageWithURL</span><span class="p">:</span> <span class="n">item</span><span class="p">.</span><span class="n">avatarURL</span><span class="p">];</span>
	<span class="c1">// 其他的一些设置
</span><span class="p">}</span></code></pre></figure>

<p>但如果用RAC，可能就是这样</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">])</span> <span class="p">{</span>
		<span class="err">@weakify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">viewModel</span><span class="p">)</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">HBItemViewModel</span> <span class="o">*</span><span class="n">viewModel</span><span class="p">)</span> <span class="p">{</span>
			<span class="err">@strongify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">self</span><span class="p">.</span><span class="n">username</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">item</span><span class="p">.</span><span class="n">text</span><span class="p">;</span>
			<span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">avatarImageView</span> <span class="nf">setImageWithURL</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">item</span><span class="p">.</span><span class="n">avatarURL</span><span class="p">];</span>
			<span class="c1">// 其他的一些设置
</span>		<span class="p">}];</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>也就是先把数据绑定，接下来只要数据有变化，就会自动响应变化。在这里，每次viewModel改变时，内容就会自动变成该viewModel的内容。</p>

<h4 id="signal">Signal</h4>

<p>Signal是RAC的核心，为了帮助理解，画了这张简化图</p>

<p><img src="/image/rac-signal.png" alt="" /></p>

<p>这里的数据源和sendXXX，可以理解为函数的参数和返回值。当Signal处理完数据后，可以向下一个Signal或Subscriber传送数据。可以看到上半部分的两个Signal是冷的(cold)，相当于实现了某个函数，但该函数没有被调用。同时也说明了Signal可以被组合使用，比如<code class="highlighter-rouge">RACSignal *signalB = [signalA map:^id(id x){return x}]</code>，或<code class="highlighter-rouge">RACSignal *signalB = [signalA take:1]</code>等等。</p>

<p>当signal被subscribe时，就会处于热(hot)的状态，也就是该函数会被执行。比如上面的第二张图，首先signalA可能发了一个网络请求，拿到结果后，把数据通过<code class="highlighter-rouge">sendNext</code>方法传递到下一个signal，signalB可以根据需要做进一步处理，比如转换成相应的Model，转换完后再<code class="highlighter-rouge">sendNext</code>到subscriber，subscriber拿到数据后，再改变ViewModel，同时因为View已经绑定了ViewModel，所以拿到的数据会自动在View里呈现。</p>

<p>还有，一个signal可以被多个subscriber订阅，这里怕显得太乱就没有画出来，但每次被新的subscriber订阅时，都会导致数据源的处理逻辑被触发一次，这很有可能导致意想不到的结果，需要注意一下。</p>

<p>当数据从signal传送到subscriber时，还可以通过<code class="highlighter-rouge">doXXX</code>来做点事情，比如打印数据。</p>

<p>通过这张图可以看到，这非常像中学时学的函数，比如 <code class="highlighter-rouge">f(x) = y</code>，某一个函数的输出又可以作为另一个函数的输入，比如 <code class="highlighter-rouge">f(f(x)) = z</code>，这也正是「函数响应式编程」(FRP)的核心。</p>

<p>有些地方需要注意下，比如把signal作为local变量时，如果没有被subscribe，那么方法执行完后，该变量会被dealloc。但如果signal有被subscribe，那么subscriber会持有该signal，直到signal sendCompleted或sendError时，才会解除持有关系，signal才会被dealloc。</p>

<h4 id="raccommand">RACCommand</h4>

<p><code class="highlighter-rouge">RACCommand</code>是RAC很重要的组成部分，可以节省很多时间并且让你的App变得更Robust，<a href="http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/">这篇文章</a>可以帮助你更深入的理解，这里简单做一下介绍。</p>

<p><code class="highlighter-rouge">RACCommand</code> 通常用来表示某个Action的执行，比如点击Button。它有几个比较重要的属性：executionSignals / errors / executing。</p>

<ul>
  <li><code class="highlighter-rouge">executionSignals</code>是signal of signals，如果直接subscribe的话会得到一个signal，而不是我们想要的value，所以一般会配合<code class="highlighter-rouge">switchToLatest</code>。</li>
  <li><code class="highlighter-rouge">errors</code>。跟正常的signal不一样，<code class="highlighter-rouge">RACCommand</code>的错误不是通过<code class="highlighter-rouge">sendError</code>来实现的，而是通过<code class="highlighter-rouge">errors</code>属性传递出来的。</li>
  <li><code class="highlighter-rouge">executing</code>表示该command当前是否正在执行。</li>
</ul>

<p>假设有这么个需求：当图片载入完后，分享按钮才可用。那么可以这样：</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">RACSignal</span> <span class="o">*</span><span class="n">imageAvailableSignal</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">imageView</span><span class="p">.</span><span class="n">image</span><span class="p">)</span> <span class="nf">map</span><span class="p">:</span><span class="n">id</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span> <span class="p">?</span> <span class="nb">@YES</span> <span class="p">:</span> <span class="nb">@NO</span><span class="p">}];</span>
<span class="n">self</span><span class="p">.</span><span class="n">shareButton</span><span class="p">.</span><span class="n">rac_command</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACCommand</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithEnabled</span><span class="p">:</span><span class="n">imageAvailableSignal</span> <span class="nf">signalBlock</span><span class="p">:</span><span class="o">^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// do share logic
</span><span class="p">}];</span></code></pre></figure>

<p>除了与<code class="highlighter-rouge">UIControl</code>绑定之外，也可以手动执行某个command，比如双击图片点赞，就可以这么实现。</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="c1">// ViewModel.m
</span><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">updatePinLikeStatus</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">pin</span><span class="p">.</span><span class="n">likedCount</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">pin</span><span class="p">.</span><span class="n">hasLiked</span> <span class="p">?</span> <span class="n">self</span><span class="p">.</span><span class="n">pin</span><span class="p">.</span><span class="n">likedCount</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">pin</span><span class="p">.</span><span class="n">likedCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">self</span><span class="p">.</span><span class="n">pin</span><span class="p">.</span><span class="n">hasLiked</span> <span class="o">=</span> <span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">pin</span><span class="p">.</span><span class="n">hasLiked</span><span class="p">;</span>
        <span class="p">};</span>
        
        <span class="n">_likeCommand</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACCommand</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSignalBlock</span><span class="p">:</span><span class="o">^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 先展示效果，再发送请求
</span>            <span class="n">updatePinLikeStatus</span><span class="p">();</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">HBAPIManager</span> <span class="nf">sharedManager</span><span class="p">]</span> <span class="nf">likePinWithPinID</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">pin</span><span class="p">.</span><span class="n">pinID</span><span class="p">];</span>
        <span class="p">}];</span>
        
        <span class="p">[</span><span class="n">_likeCommand</span><span class="p">.</span><span class="n">errors</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 发生错误时，回滚
</span>            <span class="n">updatePinLikeStatus</span><span class="p">();</span>
        <span class="p">}];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ViewController.m
</span><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
	<span class="c1">// ...
</span>    <span class="err">@weakify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">hasLiked</span><span class="p">)</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">){</span>
        <span class="err">@strongify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pinLikedCountLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">likedCount</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">likePinImageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageNamed</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">hasLiked</span> <span class="p">?</span> <span class="s">@"pin_liked"</span> <span class="p">:</span> <span class="s">@"pin_like"</span><span class="p">];</span>
    <span class="p">}];</span>
    
    <span class="n">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">tapGesture</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UITapGestureRecognizer</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
    <span class="n">tapGesture</span><span class="p">.</span><span class="n">numberOfTapsRequired</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">tapGesture</span> <span class="nf">rac_gestureSignal</span><span class="p">]</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">likeCommand</span> <span class="nf">execute</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="p">}];</span>
<span class="p">}</span></code></pre></figure>

<p>再比如某个App要通过Twitter登录，同时允许取消登录，就可以这么做 (<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/1326">source</a>)</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">_twitterLoginCommand</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACCommand</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithSignalBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">_</span><span class="p">)</span> <span class="p">{</span>
      <span class="err">@strongify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">[[</span><span class="n">self</span> 
          <span class="nf">twitterSignInSignal</span><span class="p">]</span> 
          <span class="nf">takeUntil</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">cancelCommand</span><span class="p">.</span><span class="n">executionSignals</span><span class="p">];</span>
    <span class="p">}];</span>

<span class="n">RAC</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">authenticatedUser</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">twitterLoginCommand</span><span class="p">.</span><span class="n">executionSignals</span> <span class="nf">switchToLatest</span><span class="p">];</span></code></pre></figure>

<h3 id="常用的模式">常用的模式</h3>

<h4 id="map--switchtolatest">map + switchToLatest</h4>

<p><code class="highlighter-rouge">switchToLatest:</code> 的作用是自动切换signal of signals到最后一个，比如之前的command.executionSignals就可以使用<code class="highlighter-rouge">switchToLatest:</code>。</p>

<p><code class="highlighter-rouge">map:</code>的作用很简单，对<code class="highlighter-rouge">sendNext</code>的value做一下处理，返回一个新的值。</p>

<p>如果把这两个结合起来就有意思了，想象这么个场景，当用户在搜索框输入文字时，需要通过网络请求返回相应的hints，每当文字有变动时，需要取消上一次的请求，就可以使用这个配搭。这里用另一个Demo，简单演示一下</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">NSArray</span> <span class="o">*</span><span class="n">pins</span> <span class="o">=</span> <span class="p">@[</span><span class="mi">@172230988</span><span class="p">,</span> <span class="mi">@172230947</span><span class="p">,</span> <span class="mi">@172230899</span><span class="p">,</span> <span class="mi">@172230777</span><span class="p">,</span> <span class="mi">@172230707</span><span class="p">];</span>
<span class="n">__block</span> <span class="n">NSInteger</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">RACSignal</span> <span class="o">*</span><span class="n">signal</span> <span class="o">=</span> <span class="p">[[[[</span><span class="n">RACSignal</span> <span class="nf">interval</span><span class="p">:</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span> <span class="nf">onScheduler</span><span class="p">:[</span><span class="n">RACScheduler</span> <span class="nf">scheduler</span><span class="p">]]</span>
						<span class="nf">take</span><span class="p">:</span><span class="n">pins</span><span class="p">.</span><span class="n">count</span><span class="p">]</span>
						<span class="nf">map</span><span class="p">:</span><span class="o">^</span><span class="n">id</span><span class="p">(</span><span class="n">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
							<span class="k">return</span> <span class="p">[[[</span><span class="n">HBAPIManager</span> <span class="nf">sharedManager</span><span class="p">]</span> <span class="nf">fetchPinWithPinID</span><span class="p">:[</span><span class="n">pins</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="nf">intValue</span><span class="p">]]</span> <span class="nf">doNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
								<span class="n">NSLog</span><span class="p">(</span><span class="s">@"这里只会执行一次"</span><span class="p">);</span>
							<span class="p">}];</span>
						<span class="p">}]</span>
						<span class="n">switchToLatest</span><span class="p">];</span>

<span class="p">[</span><span class="n">signal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">HBPin</span> <span class="o">*</span><span class="n">pin</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">NSLog</span><span class="p">(</span><span class="s">@"pinID:%d"</span><span class="p">,</span> <span class="n">pin</span><span class="p">.</span><span class="n">pinID</span><span class="p">);</span>
<span class="p">}</span> <span class="nf">completed</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
	<span class="n">NSLog</span><span class="p">(</span><span class="s">@"completed"</span><span class="p">);</span>
<span class="p">}];</span>

<span class="c1">// output
// 2014-06-05 17:40:49.851 这里只会执行一次
// 2014-06-05 17:40:49.851 pinID:172230707
</span><span class="o">//</span> <span class="mi">2014</span><span class="o">-</span><span class="mo">06</span><span class="o">-</span><span class="mo">05</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">49</span><span class="p">.</span><span class="mi">851</span> <span class="n">completed</span></code></pre></figure>

<h4 id="takeuntil">takeUntil</h4>

<p><code class="highlighter-rouge">takeUntil:someSignal</code> 的作用是当someSignal sendNext时，当前的signal就<code class="highlighter-rouge">sendCompleted</code>，someSignal就像一个拳击裁判，哨声响起就意味着比赛终止。</p>

<p>它的常用场景之一是处理cell的button的点击事件，比如点击Cell的详情按钮，需要push一个VC，就可以这样：</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">[[[</span><span class="n">cell</span><span class="p">.</span><span class="n">detailButton</span>
	<span class="nf">rac_signalForControlEvents</span><span class="p">:</span><span class="n">UIControlEventTouchUpInside</span><span class="p">]</span>
	<span class="nf">takeUntil</span><span class="p">:</span><span class="n">cell</span><span class="p">.</span><span class="n">rac_prepareForReuseSignal</span><span class="p">]</span>
	<span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// generate and push ViewController
</span><span class="p">}];</span></code></pre></figure>

<p>如果不加<code class="highlighter-rouge">takeUntil:cell.rac_prepareForReuseSignal</code>，那么每次Cell被重用时，该button都会被<code class="highlighter-rouge">addTarget:selector</code>。</p>

<h4 id="替换delegate">替换Delegate</h4>

<p>出现这种需求，通常是因为需要对Delegate的多个方法做统一的处理，这时就可以造一个signal出来，每次该Delegate的某些方法被触发时，该signal就会<code class="highlighter-rouge">sendNext</code>。</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">@implementation</span> <span class="nc">UISearchDisplayController</span> <span class="p">(</span><span class="nl">RAC</span><span class="p">)</span>
<span class="k">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="n">rac_isActiveSignal</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">RACSignal</span> <span class="o">*</span><span class="n">signal</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="k">return</span> <span class="n">signal</span><span class="p">;</span>
    
    <span class="cm">/* Create two signals and merge them */</span>
    <span class="n">RACSignal</span> <span class="o">*</span><span class="n">didBeginEditing</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="nf">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">searchDisplayControllerDidBeginSearch</span><span class="p">:)</span> 
                                        <span class="nf">fromProtocol</span><span class="p">:</span><span class="k">@protocol</span><span class="err">(</span><span class="nc">UISearchDisplayDelegate</span><span class="p">)]</span> <span class="n">mapReplace</span><span class="o">:</span><span class="nb">@YES</span><span class="p">];</span>
    <span class="n">RACSignal</span> <span class="o">*</span><span class="n">didEndEditing</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="nf">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">searchDisplayControllerDidEndSearch</span><span class="p">:)</span> 
                                      <span class="nf">fromProtocol</span><span class="p">:</span><span class="k">@protocol</span><span class="err">(</span><span class="nc">UISearchDisplayDelegate</span><span class="p">)]</span> <span class="n">mapReplace</span><span class="o">:</span><span class="nb">@NO</span><span class="p">];</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">merge</span><span class="p">:@[</span><span class="n">didBeginEditing</span><span class="p">,</span> <span class="n">didEndEditing</span><span class="p">]];</span>
    
    
    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">signal</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span></code></pre></figure>

<p>代码源于<a href="http://spin.atomicobject.com/2014/02/03/objective-c-delegate-pattern/">此文</a></p>

<h4 id="使用reactiveviewmodel的didbecomactivesignal">使用ReactiveViewModel的didBecomActiveSignal</h4>

<p><a href="https://github.com/ReactiveCocoa/ReactiveViewModel">ReactiveViewModel</a>是另一个project， 后面的MVVM中会讲到，通常的做法是在VC里设置VM的<code class="highlighter-rouge">active</code>属性(RVMViewModel自带该属性)，然后在VM里subscribeNext <code class="highlighter-rouge">didBecomActiveSignal</code>，比如当Active时，获取TableView的最新数据。</p>

<h4 id="racsubject的使用场景">RACSubject的使用场景</h4>

<p>一般不推荐使用<code class="highlighter-rouge">RACSubject</code>，因为它过于灵活，滥用的话容易导致复杂度的增加。但有一些场景用一下还是比较方便的，比如ViewModel的errors。</p>

<p>ViewModel一般会有多个<code class="highlighter-rouge">RACCommand</code>，那这些commands如果出现error了该如何处理呢？比较方便的方法如下：</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="c1">// HBCViewModel.h
</span>
<span class="cp">#import "RVMViewModel.h"
</span>
<span class="k">@class</span> <span class="nc">RACSubject</span><span class="p">;</span>

<span class="k">@interface</span> <span class="nc">HBCViewModel</span> <span class="p">:</span> <span class="nc">RVMViewModel</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">RACSubject</span> <span class="o">*</span><span class="n">errors</span><span class="p">;</span>
<span class="k">@end</span>



<span class="c1">// HBCViewModel.m
</span>
<span class="cp">#import "HBCViewModel.h"
#import &lt;ReactiveCocoa.h&gt;
</span>
<span class="k">@implementation</span> <span class="nc">HBCViewModel</span>

<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_errors</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSubject</span> <span class="nf">subject</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dealloc</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">_errors</span> <span class="nf">sendCompleted</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// Some Other ViewModel inherit HBCViewModel
</span>
<span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
	<span class="n">_fetchLatestCommand</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACCommand</span> <span class="nf">alloc</span><span class="p">]</span> <span class="n">initWithSignalBlock</span><span class="o">:^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span> <span class="n">input</span><span class="p">){</span>
		<span class="c1">// fetch latest data
</span>	<span class="p">}];</span>

	<span class="n">_fetchMoreCommand</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACCommand</span> <span class="nf">alloc</span><span class="p">]</span> <span class="n">initWithSignalBlock</span><span class="o">:^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span> <span class="n">input</span><span class="p">){</span>
		<span class="c1">// fetch more data
</span>	<span class="p">}];</span>

	<span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">didBecomeActiveSignal</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">_fetchLatestCommand</span> <span class="nf">execute</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
	<span class="p">}];</span>
	
	<span class="p">[[</span><span class="n">RACSignal</span>
		<span class="nf">merge</span><span class="p">:@[</span>
				<span class="n">_fetchMoreCommand</span><span class="p">.</span><span class="n">errors</span><span class="p">,</span>
				<span class="n">_fetchLatestCommand</span><span class="p">.</span><span class="n">errors</span>
				<span class="p">]]</span> <span class="nf">subscribe</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">errors</span><span class="p">];</span>

<span class="p">}</span></code></pre></figure>

<h4 id="rac_signalforselector">rac_signalForSelector</h4>

<p><code class="highlighter-rouge">rac_signalForSelector:</code> 这个方法会返回一个signal，当selector执行完时，会sendNext，也就是当某个方法调用完后再额外做一些事情。用在category会比较方便，因为Category重写父类的方法时，不能再通过<code class="highlighter-rouge">[super XXX]</code>来调用父类的方法，当然也可以手写Swizzle来实现，不过有了<code class="highlighter-rouge">rac_signalForSelector:</code>就方便多了。</p>

<p><code class="highlighter-rouge">rac_signalForSelector: fromProtocol:</code> 可以直接实现对protocol的某个方法的实现（听着有点别扭呢），比如，我们想实现UIScrollViewDelegate的某些方法，可以这么写</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">[[</span><span class="n">self</span> <span class="nf">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">scrollViewDidEndDecelerating</span><span class="p">:)</span> <span class="nf">fromProtocol</span><span class="p">:</span><span class="k">@protocol</span><span class="err">(</span><span class="nc">UIScrollViewDelegate</span><span class="p">)]</span> <span class="n">subscribeNext</span><span class="o">:^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do something
</span><span class="p">}];</span>

<span class="p">[[</span><span class="n">self</span> <span class="nf">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">scrollViewDidScroll</span><span class="p">:)</span> <span class="nf">fromProtocol</span><span class="p">:</span><span class="k">@protocol</span><span class="err">(</span><span class="nc">UIScrollViewDelegate</span><span class="p">)]</span> <span class="n">subscribeNext</span><span class="o">:^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// do something
</span><span class="p">}];</span>

<span class="n">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="n">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span></code></pre></figure>

<p>注意，这里的delegate需要先设置为nil，再设置为self，而不能直接设置为self，如果self已经是该scrollView的Delegate的话。</p>

<p>有时，我们想对selector的返回值做一些处理，但很遗憾RAC不支持，如果真的有需要的话，可以使用<a href="https://github.com/steipete/Aspects">Aspects</a></p>

<h3 id="mvvm">MVVM</h3>

<p>这是一个大话题，如果有耐心，且英文还不错的话，可以看一下Cocoa Samurai的这<a href="http://cocoasamurai.blogspot.fr/2013/03/basic-mvvm-with-reactivecocoa.html">两篇</a><a href="http://cocoamanifest.net/articles/2013/10/mvc-mvvm-frp-and-building-bridges.html">文章</a>。PS: Facebook Paper就是基于MVVM构建的。</p>

<p>MVVM是Model-View-ViewModel的简称，它们之间的关系如下</p>

<p><img src="https://camo.githubusercontent.com/3999b9fdff783edb6cee9117a08524f3b2e7c653/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f3433323533362f3836373938342f32393165643338302d663736302d313165322d393130362d6433313538333230616633392e706e67" alt="" /></p>

<p>可以看到View(其实是ViewController)持有ViewModel，这样做的好处是ViewModel更加独立且可测试，ViewModel里不应包含任何View相关的元素，哪怕换了一个View也能正常工作。而且这样也能让View/ViewController「瘦」下来。</p>

<p>ViewModel主要做的事情是作为View的数据源，所以通常会包含网络请求。</p>

<p>或许你会疑惑，ViewController哪去了？在MVVM的世界里，ViewController已经成为了View的一部分。它的主要职责是将VM与View绑定、响应VM数据的变化、调用VM的某个方法、与其他的VC打交道。</p>

<p>而RAC为MVVM带来很大的便利，比如<code class="highlighter-rouge">RACCommand</code>, UIKit的RAC Extension等等。使用MVVM不一定能减少代码量，但能降低代码的复杂度。</p>

<p>以下面这个需求为例，要求大图滑动结束时，底部的缩略图滚动到对应的位置，并高亮该缩略图；同时底部的缩略图被选中时，大图也要变成该缩略图的大图。</p>

<p><img src="/image/rac-mvvm.png" alt="" /></p>

<p>我的思路是横向滚动的大图是一个collectionView，该collectionView是当前页面VC的一个property。底部可以滑动的缩略图是一个childVC的collectionView，这两个collectionView共用一套VM，并且各自RACObserve感兴趣的property。</p>

<p>比如大图滑到下一页时，会改变VM的indexPath属性，而底部的collectionView所在的VC正好对该indexPath感兴趣，只要indexPath变化就滚动到相应的Item</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="c1">// childVC
</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>

	<span class="err">@weakify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">indexPath</span><span class="p">)</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">@strongify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">scrollToIndexPath</span><span class="p">];</span>
    <span class="p">}];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">scrollToIndexPath</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">subviews</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSIndexPath</span> <span class="o">*</span><span class="n">indexPath</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">indexPath</span><span class="p">;</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nf">scrollToItemAtIndexPath</span><span class="p">:</span><span class="n">indexPath</span> <span class="nf">atScrollPosition</span><span class="p">:</span><span class="n">UICollectionViewScrollPositionCenteredHorizontally</span> <span class="n">animated</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">subviews</span> <span class="nf">enumerateObjectsUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">UIView</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="n">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">borderWidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}];</span>
        <span class="n">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nf">cellForItemAtIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
        <span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">borderWidth</span> <span class="o">=</span> <span class="n">kHBPinsNaviThumbnailPadding</span><span class="p">;</span>
        <span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">borderColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nf">whiteColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>当点击底部的缩略图时，上面的大图也要做出变化，也同样可以通过RACObserve indexPath来实现</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="c1">// PinsViewController.m
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">super</span> <span class="nf">viewDidLoad</span><span class="p">];</span>
	<span class="err">@weakify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="p">[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">indexPath</span><span class="p">)</span>
        <span class="nf">skip</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="n">indexPath</span><span class="p">)</span> <span class="p">{</span>
            <span class="err">@strongify</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nf">scrollToItemAtIndexPath</span><span class="p">:</span><span class="n">indexPath</span> <span class="nf">atScrollPosition</span><span class="p">:</span><span class="n">UICollectionViewScrollPositionCenteredHorizontally</span> <span class="n">animated</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
    <span class="p">}];</span>
<span class="p">}</span></code></pre></figure>

<p>这里有一个小技巧，当Cell里的元素比较复杂时，我们可以给Cell也准备一个ViewModel，这个CellViewModel可以由上一层的ViewModel提供，这样Cell如果需要相应的数据，直接跟CellViewModel要即可，CellViewModel也可以包含一些command，比如likeCommand。假如点击Cell时，要做一些处理，也很方便。</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="c1">// CellViewModel已经在ViewModel里准备好了
</span><span class="k">-</span> <span class="p">(</span><span class="n">UICollectionViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">collectionView</span><span class="p">:(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">cellForItemAtIndexPath</span><span class="p">:(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
<span class="p">{</span>
    <span class="n">HBPinsCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">collectionView</span> <span class="nf">dequeueReusableCellWithReuseIdentifier</span><span class="p">:</span><span class="n">cellIdentifier</span> <span class="nf">forIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
    <span class="n">cell</span><span class="p">.</span><span class="n">viewModel</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">cellViewModels</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="nf">row</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collectionView</span><span class="p">:(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span> <span class="nf">didSelectItemAtIndexPath</span><span class="p">:(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
<span class="p">{</span>
    <span class="n">HBCellViewModel</span> <span class="o">*</span><span class="n">cellViewModel</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">cellViewModels</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="nf">row</span><span class="p">];</span>
	<span class="c1">// 对cellViewModel执行某些操作，因为Cell已经与cellViewModel绑定，所以cellViewModel的改变也会反映到Cell上
</span>	<span class="c1">// 或拿到cellViewModel的数据来执行某些操作
</span><span class="p">}</span></code></pre></figure>

<h4 id="viewmodel中signal-property-command的使用">ViewModel中signal, property, command的使用</h4>

<p>初次使用RAC+MVVM时，往往会疑惑，什么时候用signal，什么时候用property，什么时候用command？</p>

<p>一般来说可以使用property的就直接使用，没必要再转换成signal，外部RACObserve即可。使用signal的场景一般是涉及到多个property或多个signal合并为一个signal。command往往与UIControl/网络请求挂钩。</p>

<h3 id="常见场景的处理">常见场景的处理</h3>

<h4 id="检查本地缓存如果失效则去请求网络数据并缓存到本地">检查本地缓存，如果失效则去请求网络数据并缓存到本地</h4>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/1166">来源</a></p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="n">loadData</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">RACSignal</span> 
        <span class="nf">createSignal</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If the cache is valid then we can just immediately send the 
</span>            <span class="c1">// cached data and be done.
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">cacheValid</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendNext</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">cachedData</span><span class="p">];</span>
                <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendCompleted</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendError</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">staleCacheError</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}]</span> 
        <span class="c1">// Do the subscription work on some random scheduler, off the main 
</span>        <span class="c1">// thread.
</span>        <span class="nl">subscribeOn:</span><span class="p">[</span><span class="n">RACScheduler</span> <span class="nf">scheduler</span><span class="p">]];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">update</span> <span class="p">{</span>
    <span class="p">[[[[</span><span class="n">self</span> 
        <span class="nf">loadData</span><span class="p">]</span>
        <span class="c1">// Catch the error from -loadData. It means our cache is stale. Update
</span>        <span class="c1">// our cache and save it.
</span>        <span class="nl">catch:</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">self</span> <span class="nf">updateCachedData</span><span class="p">]</span> <span class="nf">doNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">self</span> <span class="nf">cacheData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
            <span class="p">}]</span><span class="err">;</span>
        <span class="p">}]</span> 
        <span class="c1">// Our work up until now has been on a background scheduler. Get our 
</span>        <span class="c1">// results delivered on the main thread so we can do UI work.
</span>        <span class="nl">deliverOn:</span><span class="n">RACScheduler</span><span class="p">.</span><span class="nf">mainThreadScheduler</span><span class="p">]</span>
        <span class="n">subscribeNext</span><span class="o">:^</span><span class="p">(</span><span class="n">id</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Update your UI based on `data`.
</span>
            <span class="c1">// Update again after `updateInterval` seconds have passed.
</span>            <span class="p">[[</span><span class="n">RACSignal</span> <span class="nf">interval</span><span class="p">:</span><span class="n">updateInterval</span><span class="p">]</span> <span class="nf">take</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="n">subscribeNext</span><span class="o">:^</span><span class="p">(</span><span class="n">id</span> <span class="n">_</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">self</span> <span class="nf">update</span><span class="p">];</span>
            <span class="p">}];</span>
        <span class="p">}];</span> 
<span class="p">}</span></code></pre></figure>

<h4 id="检测用户名是否可用">检测用户名是否可用</h4>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/1236">来源</a></p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setupUsernameAvailabilityChecking</span> <span class="p">{</span>
    <span class="n">RAC</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">availabilityStatus</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">userTemplate</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
                                      <span class="nf">throttle</span><span class="p">:</span><span class="n">kUsernameCheckThrottleInterval</span><span class="p">]</span> <span class="c1">//throttle表示interval时间内如果有sendNext，则放弃该nextValue
</span>                                      <span class="nl">map:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">username</span><span class="p">)</span> <span class="p">{</span>
                                          <span class="k">if</span> <span class="p">(</span><span class="n">username</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">return</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">UsernameAvailabilityCheckStatusEmpty</span><span class="p">)]</span><span class="err">;</span>
                                          <span class="k">return</span> <span class="p">[[[[[</span><span class="n">FIBAPIClient</span> <span class="nf">sharedInstance</span><span class="p">]</span>
                                                <span class="nf">getUsernameAvailabilityFor</span><span class="p">:</span><span class="n">username</span> <span class="nf">ignoreCache</span><span class="p">:</span><span class="nf">NO</span><span class="p">]</span>
                                              <span class="nf">map</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
                                                  <span class="n">NSNumber</span> <span class="o">*</span><span class="n">existsNumber</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s">@"exists"</span><span class="p">];</span>
                                                  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">existsNumber</span><span class="p">)</span> <span class="k">return</span> <span class="err">@</span><span class="p">(</span><span class="n">UsernameAvailabilityCheckStatusFailed</span><span class="p">);</span>
                                                  <span class="n">UsernameAvailabilityCheckStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="p">[</span><span class="n">existsNumber</span> <span class="nf">boolValue</span><span class="p">]</span> <span class="p">?</span> <span class="n">UsernameAvailabilityCheckStatusUnavailable</span> <span class="p">:</span> <span class="n">UsernameAvailabilityCheckStatusAvailable</span><span class="p">;</span>
                                                  <span class="k">return</span> <span class="err">@</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
                                              <span class="p">}]</span>
                                             <span class="nf">catch</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                                                  <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">return</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">UsernameAvailabilityCheckStatusFailed</span><span class="p">)];</span>
                                              <span class="p">}]</span> <span class="nf">startWith</span><span class="p">:</span><span class="err">@</span><span class="p">(</span><span class="n">UsernameAvailabilityCheckStatusChecking</span><span class="p">)];</span>
                                      <span class="p">}]</span>
                                      <span class="n">switchToLatest</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>可以看到这里也使用了<code class="highlighter-rouge">map</code> + <code class="highlighter-rouge">switchToLatest</code>模式，这样就可以自动取消上一次的网络请求。</p>

<p><code class="highlighter-rouge">startWith</code>的内部实现是<code class="highlighter-rouge">concat</code>，这里表示先将状态置为checking，然后再根据网络请求的结果设置状态。</p>

<h4 id="使用takeuntil来处理cell的button点击">使用takeUntil:来处理Cell的button点击</h4>

<p>这个上面已经提到过了。</p>

<h4 id="token过期后自动获取新的">token过期后自动获取新的</h4>

<p>开发APIClient时，会用到AccessToken，这个Token过一段时间会过期，需要去请求新的Token。比较好的用户体验是当token过期后，自动去获取新的Token，拿到后继续上一次的请求，这样对用户是透明的。</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">RACSignal</span> <span class="o">*</span><span class="n">requestSignal</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nf">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// suppose first time send request, access token is expired or invalid
</span>        <span class="c1">// and next time it is correct.
</span>        <span class="c1">// the block will be triggered twice.
</span>        <span class="k">static</span> <span class="n">BOOL</span> <span class="n">isFirstTime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="s">@"http://httpbin.org/ip"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isFirstTime</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">url</span> <span class="o">=</span> <span class="s">@"http://nonexists.com/error"</span><span class="p">;</span>
            <span class="n">isFirstTime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"url:%@"</span><span class="p">,</span> <span class="n">url</span><span class="p">);</span>
        <span class="p">[[</span><span class="n">AFHTTPRequestOperationManager</span> <span class="nf">manager</span><span class="p">]</span> <span class="nf">GET</span><span class="p">:</span><span class="n">url</span> <span class="nf">parameters</span><span class="p">:</span><span class="nb">nil</span> <span class="n">success</span><span class="o">:^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="n">id</span> <span class="n">responseObject</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendNext</span><span class="p">:</span><span class="n">responseObject</span><span class="p">];</span>
            <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendCompleted</span><span class="p">];</span>
        <span class="p">}</span> <span class="n">failure</span><span class="o">:^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendError</span><span class="p">:</span><span class="n">error</span><span class="p">];</span>
        <span class="p">}];</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}];</span>
    
    <span class="n">self</span><span class="p">.</span><span class="n">statusLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@"sending request..."</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">requestSignal</span> <span class="nf">catch</span><span class="p">:</span><span class="o">^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">statusLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@"oops, invalid access token"</span><span class="p">;</span>
        
        <span class="c1">// simulate network request, and we fetch the right access token
</span>        <span class="k">return</span> <span class="p">[[</span><span class="n">RACSignal</span> <span class="nf">createSignal</span><span class="p">:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">double</span> <span class="n">delayInSeconds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
            <span class="n">dispatch_time_t</span> <span class="n">popTime</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="n">delayInSeconds</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">));</span>
            <span class="n">dispatch_after</span><span class="p">(</span><span class="n">popTime</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
                <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendNext</span><span class="p">:</span><span class="nb">@YES</span><span class="p">];</span>
                <span class="p">[</span><span class="n">subscriber</span> <span class="nf">sendCompleted</span><span class="p">];</span>
            <span class="p">});</span>
            <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
        <span class="p">}]</span> <span class="nf">concat</span><span class="p">:</span><span class="n">requestSignal</span><span class="p">];</span>
    <span class="p">}]</span> <span class="nf">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">x</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">NSDictionary</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">statusLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"result:%@"</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="s">@"origin"</span><span class="p">]];</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="nf">completed</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"completed"</span><span class="p">);</span>
    <span class="p">}];</span></code></pre></figure>

<h3 id="注意事项">注意事项</h3>

<p>RAC我自己感觉遇到的几个难点是: 1) 理解RAC的理念。 2) 熟悉常用的API。3) 针对某些特定的场景，想出比较合理的RAC处理方式。不过看多了，写多了，想多了就会慢慢适应。下面是我在实践过程中遇到的一些小坑。</p>

<h4 id="reactivecocoalayout">ReactiveCocoaLayout</h4>

<p>有时Cell的内容涉及到动态的高度，就会想到用Autolayout来布局，但RAC已经为我们准备好了<a href="https://github.com/ReactiveCocoa/ReactiveCocoaLayout">ReactiveCocoaLayout</a>，所以我想不妨就拿来用一下。</p>

<p><code class="highlighter-rouge">ReactiveCocoaLayout</code>的使用好比「批地」和「盖房」，先通过<code class="highlighter-rouge">insetWidth:height:nullRect</code>从某个View中划出一小块，拿到之后还可以通过<code class="highlighter-rouge">divideWithAmount:padding:fromEdge</code> 再分成两块，或<code class="highlighter-rouge">sliceWithAmount:fromEdge</code>再分出一块。这些方法返回的都是signal，所以可以通过<code class="highlighter-rouge">RAC(self.view, frame) = someRectSignal</code> 这样来实现绑定。但在实践中发现性能不是很好，多批了几块地就容易造成主线程卡顿。</p>

<p>所以<code class="highlighter-rouge">ReactiveCocoaLayout</code>最好不用或少用。</p>

<h4 id="调试">调试</h4>

<p><img src="/image/rac-debug.png" alt="" /></p>

<p>刚开始写RAC时，往往会遇到这种情况，满屏的调用栈信息都是RAC的，要找出真正出现问题的地方不容易。曾经有一次在使用<code class="highlighter-rouge">[RACSignal combineLatest: reduce:^id{}]</code>时，忘了在Block里返回value，而Xcode也没有提示warning，然后就是莫名其妙地挂起了，跳到了汇编上，也没有调用栈信息，这时就只能通过最古老的注释代码的方式来找到问题的根源。</p>

<p>不过写多了之后，一般不太会犯这种低级错误。</p>

<h4 id="strongify--weakify-dance">strongify / weakify dance</h4>

<p>因为RAC很多操作都是在Block中完成的，这块最常见的问题就是在block直接把self拿来用，造成block和self的retain cycle。所以需要通过<code class="highlighter-rouge">@strongify</code>和<code class="highlighter-rouge">@weakify</code>来消除循环引用。</p>

<p>有些地方很容易被忽略，比如<code class="highlighter-rouge">RACObserve(thing, keypath)</code>，看上去并没有引用self，所以在<code class="highlighter-rouge">subscribeNext</code>时就忘记了weakify/strongify。但事实上<code class="highlighter-rouge">RACObserve</code>总是会引用self，即使target不是self，所以只要有<code class="highlighter-rouge">RACObserve</code>的地方都要使用weakify/strongify。</p>

<h3 id="小结">小结</h3>

<p>以上是我在做花瓣客户端和side project时总结的一些经验，但愿能带来一些帮助，有误的地方也欢迎指正和探讨。</p>

<p>推荐一下jspahrsummers的<a href="https://github.com/jspahrsummers/GroceryList">这个project</a>，虽然是用RAC3.0写的，但很多理念也可以用到RAC2上面。</p>

<p>最后感谢Github的iOS工程师们，感谢你们带来了RAC，以及在Issues里的耐心解答。</p>

					<br />
					--EOF--
					<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  /**
					* var disqus_identifier; [Optional but recommended: Define a unique identifier (e.g. post id or slug) for this thread]
					*/
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://lzyyblog.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
			<div id="footer">
	<p style="color:#ccc;font-size:12px;text-align: center">make the world a little better and easier</p>
	<p style="clear:both"></p>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1281124-24', 'limboy.me');
  ga('send', 'pageview');

</script>

		</div>
	</body>
</html>
